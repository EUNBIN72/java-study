>> chap13
> 13-1) 컬렉션 프레임워크
: 배열이 가지는 불편함을 해결하기 위해 제공되는 컬렉션 프레임워크
: 자료 구조를 사용해서 객체들을 효율적으로 관리할 수 있도록 인터페이스와 구현 클래스를 java.util 패키지에서 제공
: ex) List(ArrayList), Set(HashSet), Map(HashMap) 등

* Vector
: 저장할 객체 타입을 타입 파라미터로 표기하고 기본 생성자를 호출하여 생성
: 한번에 하나의 스레드가 메소드 실행을 완료해야만 다른 슬드가 메소드를 실행할 수 있음
: (멀티 스레드 환경에서 안전하게 객체 추가 및 삭제 -> 스레스 세이프)

* LinkedList
: 인접 참조를 링크하여 체인처럼 객체를 관리
: 특정 인덱스 객체를 제거하거나 삽입하면 앞뒤 링크만 벼경되고 나머지는 변화 없음
+) ArrayList보다 LinkedList가 4~5배정도 빠르게 처리 됨

* Set 컬렉션
: 저장 순서가 유지되지 않으며, 객체를 중복 저장할 수 없고 하나의 null만 저장 가능
: 수학의 집합과 유사함
- 저장 : add();
- 삭제 : remove();

+ Iterator() 메소드를 호출하여 반복자를 얻고, 반복자로 검색 기능 대체
: Iterator<타입> iterator = set.iterator();
- boolean | hasNext() | 가져올 객체가 있으면 true를 리턴하고 없으면 false를 리턴
- E       | next()    | 컬렉션에서 하나의 객체를 가져옴
- void    | remove()  | Set 컬렉션에서 객체를 제거

* HashSet
: Set 인터페이스의 구현 클래스
: 기본 생성자를 호출하여 생성
: Set<타입> set = new HashSet<타입>();
: 객체를 순서 없이 저장하되 저장된 객체와 동등 객체는 중복 저장하지 않음
: hashCode() 리턴값과 비교하여 같으면 -> equals() 리턴값과 비교하고 같다면 -> 동등객체임 => 저장 안함

* Map 컬렉션
: 키와 값으로 구성된 Entry 객체를 저장하는 구조
: 키는 중복 저장될 수 없으나 값은 중복 저장될 수 없음
: (기존 저장된 키와 동일한 키로 값을 저장하면 기존 값이 없어지고 새로운 값으로 대체 됨)
: Map<키 타입, 값 타입> map = ...;
- put(키, 값); // 객체 추가
- get(); // 객체 찾기
- remove(); //객체 삭제


---------------------
List 컬렉션: 중복 저장 가능 | null 저장 가능
Set 컬렉션: 저장 순서 유지X | 중복 저장 가능X | 하나의 null 저장 가능
Map 컬렉션: 키는 중복 저장X /  값은 중복 저장 가능(중복 저장하면 기존의 값은 없어지고 새로운 값으로 대체)
















